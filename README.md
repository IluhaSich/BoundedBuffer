# BoundedBuffer
Задание для самостоятельной работы
Ваша задача - реализовать класс BoundedBuffer<T>, который представляет собой буфер ограниченного размера. Этот буфер должен поддерживать операции добавления (put) и извлечения (take) элементов. Буфер должен быть потокобезопасным, что означает, что несколько потоков могут одновременно вызывать методы put и take без нарушения целостности данных.
•	buffer: Массив для хранения элементов.
•	count: Текущее количество элементов в буфере.
•	in: Индекс для вставки следующего элемента.
•	out: Индекс для извлечения следующего элемента.
class BoundedBuffer<T> {
    private final T[] buffer;
    private int count = 0;
    private int in = 0;
    private int out = 0;

    @SuppressWarnings("unchecked")
    public BoundedBuffer(int size) {
        buffer = (T[]) new Object[size];
    }

    public synchronized void put(T item) throws InterruptedException {
        // TODO: Реализуйте метод
    }

    public synchronized T take() throws InterruptedException {
        // TODO: Реализуйте метод
        return null;
    }
}

Ваша задача - реализовать класс BoundedBuffer<T>, который представляет собой буфер ограниченного размера. Этот буфер должен поддерживать операции добавления (put) и извлечения (take) элементов. Буфер должен быть потокобезопасным, что означает, что несколько потоков могут одновременно вызывать методы put и take без нарушения целостности данных.
1.	Реализовать метод put:
a.	Если буфер полон (count == buffer.length), поток должен ждать, используя wait().
b.	После освобождения места добавить элемент в буфер.
c.	Увеличить count и обновить in.
d.	Вызвать notifyAll() для оповещения ожидающих потоков.
2.	Реализовать метод take:
a.	Если буфер пуст (count == 0), поток должен ждать, используя wait().
b.	После появления элемента извлечь его из буфера.
c.	Уменьшить count и обновить out.
d.	Вызвать notifyAll() для оповещения ожидающих потоков.
e.	Вернуть извлеченный элемент.
Создайте класс BoundedBufferTest для проверки работы вашей реализации:
1.	Создайте несколько потоков-производителей, которые будут добавлять элементы в буфер.
2.	Создайте несколько потоков-потребителей, которые будут извлекать элементы из буфера.
3.	Запустите все потоки одновременно и дайте им поработать некоторое время.
4.	Проверьте, что все элементы, добавленные производителями, были корректно извлечены потребителями.
5.	Убедитесь, что не возникает исключений и взаимоблокировок.
Подсказка – задумайтесь об использовании CountDownLatch.

